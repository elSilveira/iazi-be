// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Modelo de Usuário
model User {
  id            String    @id @default(uuid())
  email         String    @unique
  name          String
  password      String
  avatar        String?   // Renamed from avatar, added based on controller/frontend usage
  bio           String?   // Added bio field based on controller/frontend usage
  phone         String?   // Added phone field based on controller/frontend usage
  role          UserRole  @default(USER) // Added role field based on controller/test usage
  points        Int       @default(0) // GAMIFICATION: User points
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")
  addresses     UserAddress[] // Relation to UserAddress
  appointments  Appointment[]
  reviews       Review[]
  badges        UserBadge[] // GAMIFICATION: Badges awarded to user
  gamificationEvents GamificationEvent[] // GAMIFICATION: History of events
  activityLogs  ActivityLog[] // FEED: User's activity logs
  posts     Post[]    // Postagens criadas pelo usuário
  comments  Comment[] // Comentários criados pelo usuário
  likes     Like[]    // Likes dados pelo usuário

  @@index([email]) // Index for login
  @@index([points]) // GAMIFICATION: Index for leaderboard
  @@map("users") // Map to lowercase table name
}

// Modelo de Endereço do Usuário (NOVO)
model UserAddress {
  id           String   @id @default(uuid())
  street       String
  number       String
  complement   String?
  neighborhood String
  city         String
  state        String
  zipCode      String   @map("zip_code")
  isPrimary    Boolean  @default(false) // Indica se é o endereço principal
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId       String   @map("user_id")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  @@index([userId]) // Index for querying user addresses
  @@index([city])   // Index for potential location filtering
  @@index([state])  // Index for potential location filtering
  @@map("user_addresses") // Map to lowercase table name
}

// Modelo de Empresa
model Company {
  id              String         @id @default(uuid())
  name            String
  description     String
  logo            String?
  coverImage      String?        @map("cover_image")
  rating          Float          @default(0)
  totalReviews    Int            @default(0) @map("total_reviews")
  yearEstablished String?        @map("year_established")
  phone           String?
  email           String?
  address         CompanyAddress? // Relation to CompanyAddress
  workingHours    Json?          @map("working_hours") // Horário de funcionamento da empresa
  categories      String[]       // TODO: Consider changing to relation with Category model.
  services        Service[]
  professionals   Professional[]
  reviews         Review[]
  createdAt       DateTime       @default(now()) @map("created_at")
  updatedAt       DateTime       @updatedAt @map("updated_at")

  @@index([name])   // Index for sorting and searching
  @@index([rating]) // Index for sorting and filtering
  @@index([categories], type: Gin) // Added GIN index for categories array (PostgreSQL)
  @@map("companies") // Map to lowercase table name
}

// Modelo de Endereço da Empresa (Renomeado de Address)
model CompanyAddress {
  id            String    @id @default(uuid())
  street        String
  number        String
  complement    String?
  neighborhood  String
  city          String
  state         String
  zipCode       String    @map("zip_code")
  company       Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  companyId     String    @unique @map("company_id") // Unique index already exists
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  @@index([city])  // Index for location filtering
  @@index([state]) // Index for location filtering
  @@map("company_addresses") // Map to lowercase table name
}

// Modelo de Serviço
model Service {
  id            String    @id @default(uuid())
  name          String
  description   String
  price         Decimal   // Changed from String to support numeric filtering/sorting
  duration      String    // Duração do serviço (ex: "30min", "1h", "1h30min") - será parseado na lógica de disponibilidade
  category      Category @relation(fields: [categoryId], references: [id]) // Changed to relation
  categoryId    Int      @map("category_id") // Added categoryId field
  image         String?
  company       Company   @relation(fields: [companyId], references: [id], onDelete: Cascade)
  companyId     String    @map("company_id")
  professionals ProfessionalService[]
  appointments  Appointment[]
  reviews       Review[]
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  @@index([name])       // Index for sorting and searching
  @@index([price])      // Index for sorting and filtering
  @@index([categoryId]) // Index for filtering
  @@index([companyId])  // Index for filtering
  @@unique([name, companyId]) // Add unique constraint for upsert in tests
  @@map("services") // Map to lowercase table name
}

// Modelo de Profissional
model Professional {
  id            String    @id @default(uuid())
  name          String
  role          String
  image         String?
  rating        Float     @default(0)
  totalReviews  Int       @default(0) @map("total_reviews")
  workingHours  Json?     @map("working_hours") // Horário de trabalho específico do profissional (pode sobrescrever o da empresa)
  company       Company?  @relation(fields: [companyId], references: [id], onDelete: Cascade) // Made relation optional
  companyId     String?   @map("company_id") // Made field optional
  services      ProfessionalService[]
  experiences   ProfessionalExperience[] // Added relation
  education     ProfessionalEducation[]  // Added relation
  scheduledAppointments Appointment[] @relation("ProfessionalAppointments")
  scheduleBlocks ScheduleBlock[] // Added relation to ScheduleBlock
  reviews       Review[]
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  @@index([name])      // Index for sorting and searching
  @@index([rating])    // Index for sorting and filtering
  @@index([companyId]) // Index for filtering
  @@index([role])      // Index for filtering and searching
  @@map("professionals") // Map to lowercase table name
}

// Modelo de Experiência Profissional (NOVO)
model ProfessionalExperience {
  id            String    @id @default(uuid())
  title         String    // Cargo
  companyName   String    @map("company_name") // Nome da empresa onde trabalhou
  description   String?   // Descrição das responsabilidades
  startDate     DateTime  @map("start_date") // Data de início
  endDate       DateTime? @map("end_date")   // Data de término (opcional se atual)
  isCurrent     Boolean   @default(false) @map("is_current") // Se é o emprego atual
  professional  Professional @relation(fields: [professionalId], references: [id], onDelete: Cascade)
  professionalId String    @map("professional_id")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  @@index([professionalId]) // Index for querying experiences
  @@map("professional_experiences")
}

// Modelo de Formação Acadêmica (NOVO)
model ProfessionalEducation {
  id            String    @id @default(uuid())
  institution   String    // Nome da instituição
  degree        String    // Grau obtido (ex: Bacharelado, Técnico)
  fieldOfStudy  String    @map("field_of_study") // Área de estudo
  startDate     DateTime  @map("start_date") // Data de início
  endDate       DateTime? @map("end_date")   // Data de término (opcional)
  description   String?   // Descrição adicional
  professional  Professional @relation(fields: [professionalId], references: [id], onDelete: Cascade)
  professionalId String    @map("professional_id")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  @@index([professionalId]) // Index for querying education
  @@map("professional_education")
}

// Tabela de relacionamento entre Profissional e Serviço
model ProfessionalService {
  professional  Professional @relation(fields: [professionalId], references: [id], onDelete: Cascade)
  professionalId String       @map("professional_id")
  service       Service      @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  serviceId     String       @map("service_id")
  price         String?      // Keeping this as String? for now, might need specific pricing per professional

  @@id([professionalId, serviceId])
  @@index([serviceId]) // Index for filtering professionals by service
  @@map("professional_services") // Map to lowercase table name
}

// Modelo de Agendamento
model Appointment {
  id            String    @id @default(uuid())
  date          DateTime  // Data e hora de início do agendamento
  status        AppointmentStatus @default(PENDING)
  user          User      @relation(fields: [userId], references: [id])
  userId        String    @map("user_id")
  service       Service   @relation(fields: [serviceId], references: [id])
  serviceId     String    @map("service_id")
  professional  Professional? @relation("ProfessionalAppointments", fields: [professionalId], references: [id], onDelete: SetNull)
  professionalId String?   @map("professional_id")
  notes         String?
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  @@index([userId])         // Index for user appointments
  @@index([serviceId])      // Index for service appointments
  @@index([professionalId]) // Index for professional appointments
  @@index([date])           // Index for filtering by date
  @@index([status])         // Added index for status filtering
  @@map("appointments") // Map to lowercase table name
}

// Modelo de Avaliação
model Review {
  id            String    @id @default(uuid())
  rating        Float
  comment       String?
  user          User      @relation(fields: [userId], references: [id])
  userId        String    @map("user_id")
  service       Service?  @relation(fields: [serviceId], references: [id])
  serviceId     String?   @map("service_id")
  professional  Professional? @relation(fields: [professionalId], references: [id])
  professionalId String?   @map("professional_id")
  company       Company?  @relation(fields: [companyId], references: [id])
  companyId     String?   @map("company_id")
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  @@index([userId])         // Index for user reviews
  @@index([serviceId])      // Index for service reviews
  @@index([professionalId]) // Index for professional reviews
  @@index([companyId])      // Index for company reviews
  @@index([rating])         // Index for filtering by rating
  @@map("reviews") // Map to lowercase table name
}

// Modelo de Categoria (NOVO)
model Category {
  id        Int      @id @default(autoincrement())
  name      String   @unique // Unique index already exists
  icon      String?
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")
  services  Service[] // Added opposite relation field

  @@map("categories") // Map to lowercase table name
}

// Modelo de Bloqueio de Agenda (NOVO)
model ScheduleBlock {
  id            String    @id @default(uuid())
  professionalId String    @map("professional_id")
  professional  Professional @relation(fields: [professionalId], references: [id], onDelete: Cascade)
  startTime     DateTime  @map("start_time") // Início do período de bloqueio/folga
  endTime       DateTime  @map("end_time")   // Fim do período de bloqueio/folga
  reason        String?   // Motivo (opcional, ex: "Férias", "Almoço", "Bloqueio Manual")
  isAllDay      Boolean   @default(false) @map("is_all_day") // Indica se o bloqueio é para o dia todo
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")

  @@index([professionalId]) // Index for querying blocks by professional
  @@index([startTime])      // Index for querying blocks by time
  @@index([endTime])        // Index for querying blocks by time
  @@map("schedule_blocks")
}

// --- GAMIFICATION MODELS ---

// Modelo de Badge (Conquista)
model Badge {
  id              String    @id @default(uuid())
  name            String    @unique // Nome do badge (ex: "Primeiro Agendamento", "Top Avaliador")
  description     String    // Descrição do que o badge representa
  iconUrl         String?   @map("icon_url") // URL para o ícone do badge
  pointsThreshold Int?      @map("points_threshold") // Pontos necessários para ganhar (opcional)
  eventTrigger    String?   @map("event_trigger") // Evento específico que concede o badge (ex: "FIRST_APPOINTMENT_COMPLETED")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  users           UserBadge[] // Relação com usuários que possuem o badge

  @@index([name])
  @@map("badges")
}

// Tabela de relacionamento entre Usuário e Badge
model UserBadge {
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String   @map("user_id")
  badge     Badge    @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  badgeId   String   @map("badge_id")
  awardedAt DateTime @default(now()) @map("awarded_at") // Quando o badge foi concedido

  @@id([userId, badgeId]) // Chave primária composta
  @@index([badgeId]) // Index para buscar usuários por badge
  @@map("user_badges")
}

// Modelo de Histórico de Eventos de Gamificação
model GamificationEvent {
  id                String    @id @default(uuid())
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId            String    @map("user_id")
  eventType         String    @map("event_type") // Tipo do evento (ex: "USER_REGISTERED", "APPOINTMENT_COMPLETED")
  pointsAwarded     Int       @map("points_awarded") // Pontos concedidos por este evento
  awardedAt         DateTime  @default(now()) @map("awarded_at")
  relatedEntityId   String?   @map("related_entity_id") // ID da entidade relacionada (ex: ID do agendamento, ID da avaliação)
  relatedEntityType String?   @map("related_entity_type") // Tipo da entidade relacionada (ex: "Appointment", "Review")

  @@index([userId])
  @@index([eventType])
  @@index([awardedAt])
  @@map("gamification_events")
}

// --- FEED MODELS ---

// Modelo de Log de Atividade
model ActivityLog {
  id                String    @id @default(uuid())
  user              User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId            String    @map("user_id")
  type              String    // Tipo da atividade (ex: "NEW_APPOINTMENT", "NEW_REVIEW")
  message           String    // Mensagem descritiva da atividade
  relatedEntityId   String?   @map("related_entity_id") // ID da entidade relacionada (ex: Appointment ID)
  relatedEntityType String?   @map("related_entity_type") // Tipo da entidade (ex: "Appointment")
  createdAt         DateTime  @default(now()) @map("created_at")

  @@index([userId]) // Index para buscar atividades do usuário
  @@index([createdAt]) // Index para ordenar o feed
  @@index([type]) // Index para filtrar por tipo de atividade
  @@map("activity_logs")
}

// --- ENUMS ---

// Enumeração para status de agendamento
enum AppointmentStatus {
  PENDING
  CONFIRMED
  COMPLETED
  CANCELLED

  @@map("appointment_status") // Map enum to lowercase name
}

// Enumeração para papel do usuário
enum UserRole {
  USER
  ADMIN
  PROFESSIONAL // Added professional role

  @@map("user_role") // Map enum to lowercase name
}



// --- SOCIAL FEATURES MODELS ---

// Modelo de Postagem
model Post {
  id        String    @id @default(uuid())
  content   String    // Conteúdo textual da postagem
  imageUrl  String?   @map("image_url") // URL de imagem opcional
  author    User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId  String    @map("author_id")
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  comments  Comment[] // Relação com comentários
  likes     Like[]    // Relação com likes

  @@index([authorId])
  @@index([createdAt]) // Para ordenar o feed
  @@map("posts")
}

// Modelo de Comentário
model Comment {
  id        String    @id @default(uuid())
  content   String    // Conteúdo textual do comentário
  author    User      @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId  String    @map("author_id")
  post      Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    String    @map("post_id")
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")
  likes     Like[]    // Relação com likes
  // parentComment Comment? @relation("NestedComments", fields: [parentCommentId], references: [id], onDelete: Cascade)
  // parentCommentId String? @map("parent_comment_id")
  // replies Comment[] @relation("NestedComments")

  @@index([authorId])
  @@index([postId])
  @@index([createdAt])
  @@map("comments")
}

// Modelo de Like (Curtida)
model Like {
  id        String    @id @default(uuid())
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String    @map("user_id")
  post      Post?     @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    String?   @map("post_id")
  comment   Comment?  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  commentId String?   @map("comment_id")
  createdAt DateTime  @default(now()) @map("created_at")

  // Garante que um usuário só pode curtir um post ou comentário uma vez
  @@unique([userId, postId])
  @@unique([userId, commentId])
  // Índices para buscar likes por post ou comentário
  @@index([postId])
  @@index([commentId])
  @@map("likes")
}

